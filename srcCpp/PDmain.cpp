#include "Graph.h"
#include <boost/program_options.hpp>
#include <string>

using namespace std;

class myComp3D
{
	bool reverse;
	Point3D p;
public:
	myComp3D(Point3D pp, const bool& revparam)
	{
		p = pp;
		reverse = revparam;
	}
	bool operator() (const std::pair<int, Point3D> & lhs, const std::pair<int, Point3D> &rhs) const
	{
		if (reverse) return (computePointDistance(p, lhs.second) > computePointDistance(p, rhs.second));
		else return (computePointDistance(p, lhs.second) < computePointDistance(p, rhs.second));
	}
};

typedef std::priority_queue<std::pair<int, Point3D>, std::vector< std::pair<int, Point3D> >, myComp3D> mypq_type;
typedef pair<double, int> myNN_pair;
/***********************************************/
char * strLicense = "THIS SOFTWARE IS PROVIDED \"AS-IS\". THERE IS NO WARRANTY OF ANY KIND. "
"NEITHER THE AUTHORS NOR THE OHIO STATE UNIVERSITY WILL BE LIABLE FOR "
"ANY DAMAGES OF ANY KIND, EVEN IF ADVISED OF SUCH POSSIBILITY. \n"
"\n"
"This software was developed (and is copyrighted) by Dayu Shi from the Jyamiti"
"group at The Ohio State University. Please do not redistribute this software. "
"This program is for academic research use only. This software uses the "
"Boost library (www.boost.org) "
"which is covered under their own licenses.\n"
"\n"
"The Boost library's license "
"(which applies to the Boost library ONLY and NOT to this program itself) is "
"as follows:\n"
"\n"
"LICENSE\n"
"---------------------------------------------------------------------------\n"
"Boost Software License - Version 1.0 - August 17th, 2003\n"
"\n"
"Permission is hereby granted, free of charge, to any person or organization "
"obtaining a copy of the software and accompanying documentation covered by "
"this license (the \"Software\") to use, reproduce, display, distribute, "
"execute, and transmit the Software, and to prepare derivative works of the "
"Software, and to permit third-parties to whom the Software is furnished to "
"do so, all subject to the following: \n"
"\n"
"The copyright notices in the Software and this entire statement, including "
"the above license grant, this restriction and the following disclaimer, "
"must be included in all copies of the Software, in whole or in part, and "
"all derivative works of the Software, unless such copies or derivative "
"works are solely in the form of machine-executable object code generated by "
"a source language processor. \n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR "
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, "
"FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT "
"SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE "
"FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, "
"ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER "
"DEALINGS IN THE SOFTWARE. \n"
"---------------------------------------------------------------------------\n";
/**********************************************************************/
/*
bool ParseCommand(int argc, char **argv, std::string &fileName1, std::string &fileName2, double &delta1, double &delta2, std::string &fileOutput)
{
	try
	{
		//Define the program options description
		namespace po = boost::program_options;
		po::options_description desc("PersistenceDistortion(Version 1) Usage");
		desc.add_options()
			(",h", "Help information;")
			(",l", "License information;")
			(",g", po::value<std::string>(&fileName1)->required(), "The file name for the first input graph;")
			(",G", po::value<std::string>(&fileName2)->required(), "The file name for the second input graph;")
			(",d", po::value<double>(&delta1)->required(), "The delta value for sampling the first input graph;")
			(",D", po::value<double>(&delta2)->required(), "The delta value for sampling the second input graph;")
			(",re", po::value<std::string>(&fileOutput)->required(), "The file name for saving the result;");
		// Parser map
		po::variables_map vm;
		try
		{
			po::store(po::parse_command_line(argc, argv, desc), vm);

			//
			if (vm.count("-h"))
			{
				std::cout << desc << std::endl;
			}
			//
			if (vm.count("-l"))
			{
				std::cout << strLicense << std::endl;
			}
			//
			po::notify(vm);
		}
		catch (boost::program_options::required_option& e)
		{
			std::cerr << "ERROR: " << e.what() << std::endl;
			return false;
		}
		catch (boost::program_options::error& e)
		{
			std::cerr << "ERROR: " << e.what() << std::endl;
			return false;
		}
	}
	catch (std::exception& e)
	{
		std::cerr << "Unhandled Exception reached the top of main: "
			<< e.what() << ", application will now exit" << std::endl;
		return false;

	}
	return true;
}
*/

/*
 *get all file names with path from {path}. and save them to {files}. exd is the file extension (.txt, .swc)
 */
void getFiles( string path, string exd, vector<string>& files )
{
	//文件句柄
	long   hFile   =   0;
	//文件信息
	struct _finddata_t fileinfo;
	string pathName, exdName;

	if (0 != strcmp(exd.c_str(), ""))
	{
		exdName = "\\*." + exd;
	}
	else
	{
		exdName = "\\*";
	}

	if((hFile = _findfirst(pathName.assign(path).append(exdName).c_str(),&fileinfo)) !=  -1)
	{
		do
		{
			//如果是文件夹中仍有文件夹,迭代之
			//如果不是,加入列表
			if((fileinfo.attrib &  _A_SUBDIR))
			{
				if(strcmp(fileinfo.name,".") != 0  &&  strcmp(fileinfo.name,"..") != 0)
					getFiles( pathName.assign(path).append("\\").append(fileinfo.name), exd, files );
			}
			else
			{
				if(strcmp(fileinfo.name,".") != 0  &&  strcmp(fileinfo.name,"..") != 0)
					files.push_back(pathName.assign(path).append("\\").append(fileinfo.name));
			}
		}while(_findnext(hFile, &fileinfo)  == 0);
		_findclose(hFile);
	}
}

void printMat(string outputFile, vector<vector<double> > &distanceMat){
	size_t rows = distanceMat.size();
	if(rows==0){
		return;
	}
	size_t columns = distanceMat[0].size();
	std::ofstream ofs;
	ofs.open(outputFile.c_str());
	ofs<<rows<<" "<<columns<<"\n";
	for(size_t i=0;i<rows;i++){
		for(size_t j=0;j<columns;j++){
			ofs<<distanceMat[i][j]<<" ";
		}
		ofs<<"\n";
	}
	ofs.close();
	ofs.clear();
}

void appendMatToFile(string outputFile, vector<vector<double> > &distanceMat){
	int rows = distanceMat.size();
	int columns = distanceMat[0].size();
	std::ofstream ofs;
	ofs.open(outputFile.c_str(),ios::app);
	for(unsigned int i=0;i<rows;i++){
		for(unsigned int j = 0;j<columns;j++){
			ofs<<distanceMat[i][j]<<" ";
		}
		ofs<<"\n";
	}
}

int getIndex(string fileName){
	int slashIndex = fileName.find_last_of('\\');
	string name = fileName.substr(slashIndex+1);
	int underscoreIndex = name.find_first_of('_');
	int index = atoi(name.substr(0,underscoreIndex).c_str());
	return index;
}

vector<vector<double> > computeDistanceMatrix(vector<string> files){
	vector<vector<double> > distanceMat;
		unsigned int fileNum = files.size();
		distanceMat.resize(fileNum);
		for (size_t i = 0; i < fileNum; ++i){
			distanceMat[i].resize(fileNum);
		}

		std::string fileName1, fileName2, fileResult = "data/dummyFile.txt";
		double delta1, delta2;
		vector<Point3D> vP;
		for(size_t i=0;i<fileNum;i++){
			cout<<"process i-th tree: "<<i<<endl;
			for(size_t j=i;j<fileNum;j++){
				fileName1 = files[i];
				fileName2 = files[j];
				delta1 = 0.1;
				delta2 = 0.1;
				std::ifstream ifs;
				double x, y, z;
				int i1, i2;
				double d;
				vP.clear();
				ifs.open(fileName1.c_str());
				int countP, countF;
				//ifs.ignore(256, '\n');
				ifs >> countP >> countF;
				//ifs.ignore(256, '\n');
				//reading first graph
				while (countP--)
				{
					ifs >> x >> y >> z;
					Point3D p;
					p.x = x;
					p.y = y;
					p.z = z;
					vP.push_back(p);
				}
				Graph ga(vP.size(), delta1, countF);
				ga.setVP(vP);
				while (countF--)
				{
					ifs >> i1 >> i2 >> d;
		//			ga.addEdge(i1, i2, computePointDistance(vP[i1], vP[i2]));
					ga.addEdge(i1, i2, d);
				}
				ifs.close();
				ifs.clear();
				//reading second graph
				vP.clear();
				ifs.open(fileName2.c_str());
		//		ifs.ignore(256, '\n');
				ifs >> countP >> countF;
		//		ifs.ignore(256, '\n');
				while (countP--)
				{
					ifs >> x >> y >> z;
					Point3D p;
					p.x = x;
					p.y = y;
					p.z = z;
					vP.push_back(p);
				}
				Graph gb(vP.size(), delta2, countF);
				gb.setVP(vP);
				while (countF--)
				{
					ifs >> i1 >> i2 >> d;
		//			gb.addEdge(i1, i2, computePointDistance(vP[i1], vP[i2]));
					gb.addEdge(i1, i2, d);
				}
				ifs.close();
				ifs.clear();
				//computing persistence-distortion distance, this return the bottleneck distance
				double result;
				result = ga.computePersistenceDistortionDistance(gb, fileResult);
				distanceMat[i][j] = result;
				distanceMat[j][i] = result;
			}
		}
		return distanceMat;
}

vector<string> getFixIndexFiles(vector<string> files){
	vector<string> filesFixIndex;
	filesFixIndex.resize(files.size());
	for(unsigned int i=0;i<files.size();i++){
		string next = files[i];
		int index = getIndex(next);
		filesFixIndex[index-1] = next;
	}
	for(size_t i=0;i<files.size();i++){
		cout<<filesFixIndex[i]<<endl;
	}
	return filesFixIndex;
}

void getDistanceMatrixFixIndex(string filePath, string outputFile){

	//file name start with its index eg. 12_name.swc, this index start from 1
	vector<string> files;
	getFiles(filePath, "swc", files);
	vector<string> filesFixIndex = getFixIndexFiles(files);
	vector<vector<double> > distanceMat = computeDistanceMatrix(filesFixIndex);
	printMat(outputFile,distanceMat);
}

void getDistanceMatrix(string filePath, string outputFile){

	//get all the input file names with their path
	vector<string> files;
	getFiles(filePath, "swc", files);
	for(size_t i=0;i<files.size();i++){
		cout<<files[i]<<endl;
	}

	//use the for loop to compute bottleneck distance between every pair of graphs
	vector<vector<double> > distanceMat = computeDistanceMatrix(files);

	//print distance matrix to file
	printMat(outputFile,distanceMat);
	string fileIndexName = "data/output_SUM/Index_Name.txt";
	std::ofstream ofs;
	ofs.open(fileIndexName.c_str());
	for(size_t i=0;i<files.size();i++){
		ofs<<i<<": "<<files[i]<<"\n";
	}
	ofs.close();
	ofs.clear();
}

void readMat(string fileName,vector<vector<double> > &distanceMat){
	std::ifstream ifs;
	ifs.open(fileName.c_str());
	unsigned int size;
	ifs>>size;
	ifs>>size;
	distanceMat.resize(size);
	for (size_t i = 0; i < size; ++i){
		distanceMat[i].resize(size);
	}
	double next;
	for(size_t i = 0;i<size;i++){
		for(size_t j = 0;j<size;j++){
			ifs>>next;
			distanceMat[i][j] = next;
		}
	}
	ifs.close();
	ifs.clear();
}
void findMidPoint(vector<vector<double> > &distanceMat, int &midIndex){
	//find the index of tree that has the minimum average distance to all the other trees.
	midIndex = 0;
	double minDistSum = 0;
	for(size_t i=0;i<distanceMat.size();i++){
		minDistSum+=distanceMat[0][i];
	}
	for(size_t i=0;i<distanceMat.size();i++){
		int currentDistSum = 0;
		for(size_t j=0;j<distanceMat.size();j++){
			currentDistSum+=distanceMat[i][j];
		}
		if(currentDistSum<minDistSum){
			minDistSum = currentDistSum;
			midIndex = i;
		}
	}
}
void sortDistanceMat(vector<vector<double> > &distanceMat, int midIndex, vector<vector<double> > &weightedDistanceMat, vector<pair<double,size_t> > &reorderIndex){
	reorderIndex.resize(distanceMat[midIndex].size());
	for(size_t i=0;i<distanceMat.size();i++){
		reorderIndex[i] = make_pair(distanceMat[midIndex][i],i);
	}
	sort(reorderIndex.begin(),reorderIndex.end());
	// build a new distance matrix to store weighted distance;
	weightedDistanceMat.resize(distanceMat.size());
	for (size_t i = 0; i < distanceMat.size(); ++i)
		weightedDistanceMat[i].resize(distanceMat.size());

	for(size_t i=0;i<distanceMat.size();i++){
		for(size_t j=0;j<distanceMat.size();j++){
			weightedDistanceMat[i][j] = distanceMat[reorderIndex[i].second][reorderIndex[j].second];
		}
	}
}
void sortDistMatBasedGeodesic(string geodesicFile,string geodesicWeighted, string euclideanFile, string euclideanWeighted){
	/*
	 * sort the distance matrix
	 */
	//read matrix from file to memory
	// read the first file(geodesicFile)
	vector<vector<double> > distanceMat;
	readMat(geodesicFile,distanceMat);


	//find the index of tree that has the minimum average distance to all the other trees.
	int midIndex = 0;
	findMidPoint(distanceMat, midIndex);

	//sort the tree based on the distance to the midIndex-th tree
	vector<pair<double,size_t> > vp;
	vector<vector<double> > weightedDistanceMat;
	sortDistanceMat(distanceMat, midIndex, weightedDistanceMat, vp);

	//print the weighted distance matrix to file
	printMat(geodesicWeighted,weightedDistanceMat);
	/*
	 * print the index of sorted distance {vp}
	 */

	string indexFile = "data/output/indexFileBasedOnGeodesicDist.txt";
	std::ofstream ofs;
	ofs.open(indexFile.c_str());
	for(size_t i=0;i<distanceMat.size();i++){
		ofs<<vp[i].second<<"\n";
	}
	ofs.close();
	ofs.clear();

	/*
	 * read the second file (euclideanFile)
	 */
	readMat(euclideanFile,distanceMat);

	for(size_t i=0;i<distanceMat.size();i++){
		for(size_t j=0;j<distanceMat.size();j++){
			weightedDistanceMat[i][j] = distanceMat[vp[i].second][vp[j].second];
		}
	}

	printMat(euclideanWeighted,weightedDistanceMat);
}
/*
 * find minimum distance between different points.
 * the distance may be zero. (we assume they are not zero)
 */
void findMinIndex(vector<vector<double> > &distanceMat, int &indexI, int &indexJ){
	indexI=0;
	indexJ=1;
	for(unsigned int i=0;i<distanceMat.size();i++){
		for(unsigned int j=0;j<distanceMat.size();j++){
			if(i!=j&&distanceMat[i][j]<distanceMat[indexI][indexJ]){
				indexI = i;
				indexJ = j;
			}
		}
	}
}
void findMaxIndex(vector<vector<double> > &distanceMat, int &indexI, int &indexJ){
	indexI = 0;
	indexJ = 0;
	for(unsigned int i=0;i<distanceMat.size();i++){
		for(unsigned int j=0;j<distanceMat.size();j++){
			if(distanceMat[i][j]>distanceMat[indexI][indexJ]){
				indexI = i;
				indexJ = j;
			}
		}
	}
}
/*
 * normalize the distance matrix based on the minimum distance.
 * assume the minimum distance is not zero.
 */
void normalizeMat(vector<vector<double> > &distanceMat, unsigned int indexI, unsigned int indexJ){
	for(unsigned int i=0;i<distanceMat.size();i++){
		for(unsigned int j=0;j<distanceMat.size();j++){
			if(i!=indexI||j!=indexJ){
				distanceMat[i][j]=distanceMat[i][j]/distanceMat[indexI][indexJ];
			}
		}
	}
	distanceMat[indexI][indexJ] = 1;
}
void addMat(vector<vector<double> > &mat1, vector<vector<double> > &mat2, vector<vector<double> > &mat3){
	unsigned int size = mat1.size();
	mat3.resize(size);
	for (size_t i = 0; i < size; ++i){
		mat3[i].resize(size);
	}
	for(size_t i = 0;i<size;i++){
		for(size_t j = 0;j<size;j++){
			mat3[i][j] = mat1[i][j]+mat2[i][j];
		}
	}
}

void combineMatTakeMax(vector<vector<double> > &mat1, vector<vector<double> > &mat2, vector<vector<double> > &mat3){
	unsigned int size = mat1.size();
	mat3.resize(size);
	for (size_t i = 0; i < size; ++i){
		mat3[i].resize(size);
	}
	for(size_t i = 0;i<size;i++){
		for(size_t j = 0;j<size;j++){
			//mat3[i][j] = mat1[i][j]+mat2[i][j];
			if(mat1[i][j]>mat2[i][j]){
				mat3[i][j] = mat1[i][j];
			}else{
				mat3[i][j] = mat2[i][j];
			}
		}
	}
}


void sortCombineDistMat(string geodesicFile, string euclideanFile, string combineWeighted){
	vector<vector<double> > distanceMatGeodesic;
	vector<vector<double> > distanceMatEuclidean;
	int indexI = 0;
	int indexJ = 0;
	readMat(geodesicFile, distanceMatGeodesic);
	//findMinIndex(distanceMatGeodesic,indexI, indexJ);
	findMaxIndex(distanceMatGeodesic,indexI, indexJ);
	normalizeMat(distanceMatGeodesic,indexI, indexJ);

	readMat(euclideanFile, distanceMatEuclidean);
	//findMinIndex(distanceMatEuclidean,indexI, indexJ);
	findMaxIndex(distanceMatEuclidean,indexI, indexJ);
	normalizeMat(distanceMatEuclidean,indexI, indexJ);
	vector<vector<double> > distanceMatCombine;
	addMat(distanceMatEuclidean, distanceMatGeodesic, distanceMatCombine);

	vector<pair<double,size_t> > reorderIndex;
	vector<vector<double> > weightedDistanceMat;
	int midIndex;
	findMidPoint(distanceMatCombine,midIndex);
	sortDistanceMat(distanceMatCombine,midIndex, weightedDistanceMat, reorderIndex);
	printMat(combineWeighted, weightedDistanceMat);
	//print reordered index file
	string indexFile = "data/output/indexFileBasedOnCombinedDist.txt";
	std::ofstream ofs;
	ofs.open(indexFile.c_str());
	for(size_t i=0;i<reorderIndex.size();i++){
		ofs<<reorderIndex[i].second<<"\n";
	}
	ofs.close();
	ofs.clear();
}

void sortCombineDistMatTakeMax(string matFile1, string matFile2, string outputFile){
	vector<vector<double> > mat1;
	vector<vector<double> > mat2;
	int indexI = 0;
	int indexJ = 0;
	readMat(matFile1, mat1);
	readMat(matFile2, mat2);

	vector<vector<double> > distanceMatCombineMax;
	combineMatTakeMax(mat1,mat2,distanceMatCombineMax);

	vector<pair<double,size_t> > reorderIndex;
	vector<vector<double> > weightedDistanceMat;
	int midIndex;
	findMidPoint(distanceMatCombineMax,midIndex);
	sortDistanceMat(distanceMatCombineMax,midIndex, weightedDistanceMat, reorderIndex);
	printMat(outputFile, weightedDistanceMat);
	//print reordered index file
	string indexFile = "data/output/indexFileDiameterEuclideanMax.txt";
	std::ofstream ofs;
	ofs.open(indexFile.c_str());
	for(size_t i=0;i<reorderIndex.size();i++){
		ofs<<reorderIndex[i].second<<"\n";
	}
	ofs.close();
	ofs.clear();
}

void combineDistMatTakeMax(string matFile1, string matFile2, string outputFile){
	vector<vector<double> > mat1;
	vector<vector<double> > mat2;
	int indexI = 0;
	int indexJ = 0;
	readMat(matFile1, mat1);
	readMat(matFile2, mat2);

	vector<vector<double> > distanceMatCombineMax;
	combineMatTakeMax(mat1,mat2,distanceMatCombineMax);
	printMat(outputFile, distanceMatCombineMax);
}

double computeEuclideanDiameter(string fileName){
	std::ifstream ifs;
	ifs.open(fileName.c_str());
	vector<Point3D> vp;
	double x, y, z;
	int countP, countF;
	ifs >> countP >> countF;
	while (countP--)
	{
		ifs >> x >> y >> z;
		Point3D p;
		p.x = x;
		p.y = y;
		p.z = z;
		vp.push_back(p);
	}
	ifs.close();
	ifs.clear();
	double diameter = 0;
	for(unsigned int i=0;i<vp.size();i++){
		for(unsigned int j=i+1;j<vp.size();j++){
			double tmpDistance = computePointDistance(vp[i],vp[j]);
			if(diameter<tmpDistance){
				diameter = tmpDistance;
			}
		}
	}
	return diameter;
}

double computeGeodesicDiameter(string fileName){
	std::ifstream ifs;
	ifs.open(fileName.c_str());
	vector<Point3D> vp;
	double x, y, z;
	int countP, countF;
	ifs >> countP >> countF;
	while (countP--)
	{
		ifs >> x >> y >> z;
		Point3D p;
		p.x = x;
		p.y = y;
		p.z = z;
		vp.push_back(p);
	}
	vector<vector<double> > connectionMat;
	connectionMat.resize(vp.size());
	for(unsigned int i=0;i<vp.size();i++){
		connectionMat[i].resize(vp.size());
	}
	for(unsigned int i=0;i<vp.size();i++){
		connectionMat[i][i] = 0;
		for(unsigned int j=i+1;j<vp.size();j++){
			connectionMat[i][j] = DBL_MAX;
			connectionMat[j][i] = DBL_MAX;
		}
	}
	int idx1,idx2;
	double dist;
	while(countF--){
		ifs >>idx1>>idx2>>dist;
		connectionMat[idx1][idx2] = dist;
		connectionMat[idx2][idx1] = dist;
	}
	ifs.close();
	ifs.clear();
	for(int k=0;k<vp.size();k++){
		for(int i=0;i<vp.size();i++){
			for(int j=i+1;j<vp.size();j++){
				connectionMat[i][j] = min(connectionMat[i][j],connectionMat[i][k]+connectionMat[k][j]);
				connectionMat[j][i] = connectionMat[i][j];
			}
		}
	}
	double diameter = 0;
	for(int i=0;i<vp.size();i++){
		for(int j=i+1;j<vp.size();j++){
			diameter = max(diameter,connectionMat[i][j]);
		}
	}
	return diameter;
}

vector<double> getEuclideanDiameterArray(string filePath){
	vector<string> files;
	getFiles(filePath, "swc", files);

	vector<double> diameters;
	diameters.resize(files.size());
	string fileName;
	for(unsigned int i=0;i<files.size();i++){
		fileName = files[i];
		diameters[i] = computeEuclideanDiameter(fileName);
	}
	return diameters;
}

vector<double> getEuclideanDiameterArrayFixIndex(string filePath){
	vector<string> files;
	getFiles(filePath, "swc", files);
	vector<string> filesFixIndex = getFixIndexFiles(files);
	vector<double> diameters;
	diameters.resize(filesFixIndex.size());
	string fileName;
	for(unsigned int i=0;i<filesFixIndex.size();i++){
		fileName = filesFixIndex[i];
		diameters[i] = computeEuclideanDiameter(fileName);
	}
	return diameters;
}

vector<double> getGeodesicDiameterArray(string filePath){
	vector<string> files;
	getFiles(filePath,"swc",files);

	vector<double> diameters;
	diameters.resize(files.size());
	string fileName;
	for(unsigned int i=0;i<files.size();i++){
		fileName = files[i];
		cout<<"compute geodesic diameter: "<<fileName<<endl;
		diameters[i] = computeGeodesicDiameter(fileName);
	}
	return diameters;
}

vector<double> getGeodesicDiameterArrayFixIndex(string filePath){
	vector<string> files;
	getFiles(filePath,"swc",files);
	vector<string> filesFixIndex = getFixIndexFiles(files);
	vector<double> diameters;
	diameters.resize(filesFixIndex.size());
	string fileName;
	for(unsigned int i=0;i<filesFixIndex.size();i++){
		fileName = filesFixIndex[i];
		cout<<"compute geodesic diameter: "<<fileName<<endl;
		diameters[i] = computeGeodesicDiameter(fileName);
	}
	return diameters;
}

void getDiameterDistMat(string filePath, string outputFile){
	vector<double> diameters = getEuclideanDiameterArrayFixIndex(filePath);
	vector<vector<double> > diameterMat;
	int size = diameters.size();
	diameterMat.resize(size);
	for(int i=0;i<size;i++){
		diameterMat[i].resize(size);
	}
	for(int i=0;i<size;i++){
		diameterMat[i][i] = 0;
		for(int j=i+1;j<size;j++){
			diameterMat[i][j] = fabs(diameters[i]-diameters[j]);
			diameterMat[j][i] = diameterMat[i][j];
		}
	}
	printMat(outputFile, diameterMat);
}

double findMax(vector<double> v){
	double m = 0;
	for(unsigned int i=0;i<v.size();i++){
		m = max(m,v[i]);
	}
	return m;
}

void matrixDivide(vector<vector<double> > &mat, double divisor){
	for(unsigned int i=0;i<mat.size();i++){
		for(unsigned int j=0;j<mat[0].size();j++){
			mat[i][j] = mat[i][j]/divisor;
		}
	}
}

bool geodesicDiameterMaxFind = false;
double deodesicDiameterMaxSaved = 1;
void combineGEDistMat(string geodesicMatFile, string EuclideanMatFile,string outputFile, string geodesicFilePath, string euclideanFilePath){
	vector<double> geodesicDiameters = getGeodesicDiameterArray(geodesicFilePath);
	vector<double> euclideanDiameters = getEuclideanDiameterArray(euclideanFilePath);
	double geodesicDiameterMax = findMax(geodesicDiameters);
	double euclideanDiameterMax = findMax(euclideanDiameters);
	/*
	vector<double> euclideanDiameters = getEuclideanDiameterArray(euclideanFilePath);
	double euclideanDiameterMax = findMax(euclideanDiameters);
	double geodesicDiameterMax = deodesicDiameterMaxSaved;
	if(!geodesicDiameterMaxFind){
		vector<double> geodesicDiameters = getGeodesicDiameterArray(geodesicFilePath);
		deodesicDiameterMaxSaved = findMax(geodesicDiameters);
		geodesicDiameterMaxFind = true;
		geodesicDiameterMax = deodesicDiameterMaxSaved;
	}
	*/

	vector<vector<double> > geodesicMat;
	vector<vector<double> > euclideanMat;
	readMat(geodesicMatFile, geodesicMat);
	readMat(EuclideanMatFile, euclideanMat);
	matrixDivide(geodesicMat,geodesicDiameterMax);
	matrixDivide(euclideanMat,euclideanDiameterMax);
	vector<vector<double> > distanceMatCombine;
	addMat(geodesicMat, euclideanMat, distanceMatCombine);
	printMat(outputFile,distanceMatCombine);
}

void combineDistMatAddUp(string matFile1, string matFile2, string outputFile){
	vector<vector<double> > mat1;
	vector<vector<double> > mat2;
	readMat(matFile1, mat1);
	readMat(matFile2, mat2);
	vector<vector<double> > matSum;
	addMat(mat1,mat2,matSum);
	printMat(outputFile,matSum);
}

int main_for_Giogio_data(int argc, char **argv)
{
	cout<<"run max version"<<endl;
	string euclideanFilePath = "data/ResearchData/Euclidean";
	string outputFile = "data/output/euclideanDistanceMat_MaxXY.txt";
	//getDistanceMatrix(euclideanFilePath,outputFile);
	string geodesicFilePath = "data/ResearchData/Geodesic";
	outputFile = "data/output/geodesicDistanceMat_MaxXY.txt";
	//getDistanceMatrix(geodesicFilePath,outputFile);

	string outputFileDiameter = "data/output/diameterDistMat.txt";
	//getDiameterDistMat(euclideanFilePath, outputFileDiameter);


	string geodesicFile = "data/output/geodesicDistanceMat.txt";
	string geodesicWeighted = "data/output/geodesicWeightedDistanceMat.txt";
	string euclideanFile = "data/output/euclideanDistanceMat_MaxXY.txt";
	string euclideanWeighted = "data/output/euclideanWeightedDistanceMat.txt";
	//sortDistMatBasedGeodesic(geodesicFile, geodesicWeighted, euclideanFile, euclideanWeighted);

	string combineWeighted = "data/output/combineWeighted.txt";
	//sortCombineDistMat(geodesicFile, euclideanFile, combineWeighted);
	string combineGEMatWithoutSort = "data/output/combineGEMatNormalize_MaxXY.txt";
	//combineGEDistMat(geodesicFile,euclideanFile,combineGEMatWithoutSort,geodesicFilePath,euclideanFilePath);
	string diameterEuclideanMax = "data/output/combineDiameterEuclideanMax.txt";
	//sortCombineDistMatTakeMax(outputFileDiameter, euclideanFile, diameterEuclideanMax);

	string diameterEuclideanMaxWithoutSort = "data/output/combineDiameterEuclideanMaxWithoutSort_MaxXY.txt";
	//combineDistMatTakeMax(outputFileDiameter,euclideanFile, diameterEuclideanMaxWithoutSort);
/*
	//4 class neural trees//
	string HBfourClassEuclideanPath = "data/ResearchData/FourClassHippoBreak/Euclidean";
	string HBfourClassGeodesicPath = "data/ResearchData/FourClassHippoBreak/Geodesic";
	string HBfourClassEuclideanoutputfile = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaLinfty_Personly_Euclidean.txt";
	string HBfourClassGeodesicoutputfile = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaLinfty_Personly_Geodesic.txt";
	//getDistanceMatrixFixIndex(HBfoutClassEuclideanPath,HBfourClassEuclideanoutputfile);
	//getDistanceMatrixFixIndex(HBfourClassGeodesicPath,HBfourClassGeodesicoutputfile);

	//G E SumXY MAX
	string fourClassGeodesicFile = "data/output_FourClass_HippoBreak/MAX/dBMax_deltaL1_Personly_Geodesic.txt";
	string fourClassEuclideanFile = "data/output_FourClass_HippoBreak/MAX/dBMax_deltaL1_Personly_Euclidean.txt";
	string GENormalizeOutput = "data/output_FourClass_HippoBreak/MAX/dBMax_deltaL1.txt";
	//combineGEDistMat(fourClassGeodesicFile,fourClassEuclideanFile,GENormalizeOutput,HBfourClassGeodesicPath,HBfourClassEuclideanPath);
	//G E MaxXY MAX
	fourClassGeodesicFile = "data/output_FourClass_HippoBreak/MAX/dBMax_deltaLinfty_Personly_Geodesic.txt";
	fourClassEuclideanFile = "data/output_FourClass_HippoBreak/MAX/dBMax_deltaLinfty_Personly_Euclidean.txt";
	GENormalizeOutput = "data/output_FourClass_HippoBreak/MAX/dBMax_deltaLinfty.txt";
	//combineGEDistMat(fourClassGeodesicFile,fourClassEuclideanFile,GENormalizeOutput,HBfourClassGeodesicPath,HBfourClassEuclideanPath);
	//G E SumXY SUM
	fourClassGeodesicFile = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaL1_Personly_Geodesic.txt";
	fourClassEuclideanFile = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaL1_Personly_Euclidean.txt";
	GENormalizeOutput = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaL1.txt";
	//combineGEDistMat(fourClassGeodesicFile,fourClassEuclideanFile,GENormalizeOutput,HBfourClassGeodesicPath,HBfourClassEuclideanPath);
	//G E MaxXY SUM
	fourClassGeodesicFile = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaLinfty_Personly_Geodesic.txt";
	fourClassEuclideanFile = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaLinfty_Personly_Euclidean.txt";
	GENormalizeOutput = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaLinfty.txt";
	//combineGEDistMat(fourClassGeodesicFile,fourClassEuclideanFile,GENormalizeOutput,HBfourClassGeodesicPath,HBfourClassEuclideanPath);

	outputFileDiameter = "data/output_FourClass_HippoBreak/FourClass_DiameterMat.txt";
	getDiameterDistMat(HBfourClassEuclideanPath, outputFileDiameter);
	//MaxXY MAX(E D)
	fourClassEuclideanFile = "data/output_FourClass_HippoBreak/MAX/dBMax_deltaLinfty_Personly_Euclidean.txt";
	string EDoutput = "data/output_FourClass_HippoBreak/MAX/dBMax_deltaLinfty_combMax.txt";
	combineDistMatTakeMax(outputFileDiameter,fourClassEuclideanFile, EDoutput);
	//SumXY MAX(E D)
	fourClassEuclideanFile = "data/output_FourClass_HippoBreak/MAX/dBMax_deltaL1_Personly_Euclidean.txt";
	EDoutput = "data/output_FourClass_HippoBreak/MAX/dBMax_deltaL1_combMax.txt";
	combineDistMatTakeMax(outputFileDiameter,fourClassEuclideanFile, EDoutput);
	//MaxXY SUM(E D)
	fourClassEuclideanFile = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaLinfty_Personly_Euclidean.txt";
	EDoutput = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaLinfty_combSum.txt";
	combineDistMatAddUp(outputFileDiameter,fourClassEuclideanFile,EDoutput);
	//SumXY SUM(E D)
	fourClassEuclideanFile = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaL1_Personly_Euclidean.txt";
	EDoutput = "data/output_FourClass_HippoBreak/SUM/dBSum_deltaL1_combSum.txt";
	combineDistMatAddUp(outputFileDiameter,fourClassEuclideanFile,EDoutput);
*/




	//4 class neural trees//
		string fourClassEuclideanPath = "data/ResearchData/FourClass/Euclidean";
		string fourClassGeodesicPath = "data/ResearchData/FourClass/Geodesic";

		outputFileDiameter = "data/output_FourClass/FourClass_DiameterMat.txt";
		getDiameterDistMat(fourClassEuclideanPath, outputFileDiameter);
		//MaxXY MAX(E D)
		string fourClassEuclideanFile = "data/output_FourClass/dBMax_deltaLinfty_Personly_Euclidean.txt";
		string EDoutput = "data/output_FourClass/dBMax_deltaLinfty_combMax.txt";
		combineDistMatTakeMax(outputFileDiameter,fourClassEuclideanFile, EDoutput);
		//SumXY MAX(E D)
		fourClassEuclideanFile = "data/output_FourClass/dBMax_deltaL1_Personly_Euclidean.txt";
		EDoutput = "data/output_FourClass/dBMax_deltaL1_combMax.txt";
		combineDistMatTakeMax(outputFileDiameter,fourClassEuclideanFile, EDoutput);
		//MaxXY SUM(E D)
		fourClassEuclideanFile = "data/output_SUM_FourClass/dBSum_deltaLinfty_Personly_Euclidean.txt";
		EDoutput = "data/output_SUM_FourClass/dBSum_deltaLinfty_combSum.txt";
		combineDistMatAddUp(outputFileDiameter,fourClassEuclideanFile,EDoutput);
		//SumXY SUM(E D)
		fourClassEuclideanFile = "data/output_SUM_FourClass/dBSum_deltaL1_Personly_Euclidean.txt";
		EDoutput = "data/output_SUM_FourClass/dBSum_deltaL1_combSum.txt";
		combineDistMatAddUp(outputFileDiameter,fourClassEuclideanFile,EDoutput);
	return 0;
}

void getNearestKNeighbor(string input, string output, int k){
	vector<vector<double> > distanceMat;
	readMat(input,distanceMat);
	vector<vector<int> > nearestNeighbor;
	nearestNeighbor.resize(distanceMat.size());
	for(size_t i = 0; i < distanceMat.size();i++){
		nearestNeighbor[i].resize(k);
	}
	for(size_t i = 0; i<distanceMat.size();i++){
		std::priority_queue<myNN_pair, vector<myNN_pair> > pq;
		double min = 0;
		for(size_t j = 0; j<distanceMat.size();j++){
			if(j == i) continue;
			pq.push(std::pair<double, int>(distanceMat[i][j], j+1));// file index start from 1.
			if(pq.size()>k) {
				if(min>pq.top().first) cout<<"test"<<endl;
				pq.pop();
			}
		}
		for(size_t j = 0;j<k&&pq.size()>0;j++){
			nearestNeighbor[i][j] = pq.top().second;
			pq.pop();
		}
	}
	std::ofstream ofs;
	ofs.open(output.c_str());
	for(size_t i=0;i<nearestNeighbor.size();i++){
		for(size_t j = 0;j<k;j++){
			ofs<<nearestNeighbor[i][j]<<" ";
		}
		ofs<<"\n";
	}
	ofs.close();
	ofs.clear();
}

void getNearestNeighbor(string input, string output){
	getNearestKNeighbor(input, output, 1);
}

/* build density distance matrix */
vector<pair<double, int> > getDensityCurve(string inputFile){
	std::ifstream ifs;
	ifs.open(inputFile.c_str());
	unsigned int length;
	ifs>>length;
	double distance;
	int count;
	vector<pair<double, int> > densityCurve;
	for(size_t i = 0; i<length; i++){
		ifs>>distance>>count;
		densityCurve.push_back(make_pair(distance, count));
	}
	ifs.close();
	ifs.clear();
	return densityCurve;
}

double computeDensityDistance(vector<pair<double, int> > densityCurve1, vector<pair<double, int> > densityCurve2){
	double result = 0;
	int idx1 = 1;
	int idx2 = 1;
	while(idx1<densityCurve1.size()&&idx2<densityCurve2.size()){
		pair<double, int> p1 = densityCurve1[idx1-1];
		pair<double, int> p2 = densityCurve2[idx2-1];
		if(densityCurve1[idx1].first<densityCurve2[idx2].first){
			result+=abs((densityCurve1[idx1].first-max(p1.first, p2.first))*(p1.second-p2.second));
			idx1++;
		}else{
			result+=abs(max(densityCurve1[idx1-1].first, densityCurve2[idx2].first)*(p1.second-p2.second));
			idx2++;
		}
	}
	while(idx1<densityCurve1.size()){
		result+=densityCurve1[idx1++].second;
	}
	while(idx2<densityCurve2.size()){
		result+=densityCurve2[idx2++].second;
	}
	return result;
}

vector<vector<double> > computeDensityDistanceMatrix(vector<string> files){
	vector<vector<double> > distanceMat;
	unsigned int fileNum = files.size();
	distanceMat.resize(fileNum);
	for (size_t i = 0; i < fileNum; ++i){
		distanceMat[i].resize(fileNum);
	}

	std::string fileName1, fileName2, fileResult = "data/dummyFile.txt";
	double result;
	for(size_t i=0;i<fileNum;i++){
		cout<<"process i-th tree: "<<i<<endl;
		fileName1 = files[i];
		vector<pair<double, int> > densityCurve1 = getDensityCurve(fileName1);
		for(size_t j=i;j<fileNum;j++){
			fileName2 = files[j];
			vector<pair<double, int> > densityCurve2 = getDensityCurve(fileName2);
			result = computeDensityDistance(densityCurve1, densityCurve2);
			distanceMat[i][j] = result;
			distanceMat[j][i] = result;
		}
	}
	return distanceMat;
}

void getDensityDistanceMatrixFixIndex(string filePath, string outputFile){

	//file name start with its index eg. 12_name.swc, this index start from 1
	vector<string> files;
	getFiles(filePath, "swc", files);
	vector<string> filesFixIndex = getFixIndexFiles(files);
	vector<vector<double> > distanceMat = computeDensityDistanceMatrix(filesFixIndex);
	printMat(outputFile,distanceMat);
}
/* end build density distance matrix */

int main(int argc, char **argv){
	string ZhaoEuclideanPath = "data/Zhao_trees/output_Euclidean";
	string ZhaoEuclideanOutput_dBSum_Linfty = "data/Zhao_trees/output/dBSum_deltaLinfty_Personly_Euclidean.txt"; //SUM/dBSum_deltaLinfty_Personly_Euclidean.txt
	string ZhaoEuclideanOutput_dBSum_l1 = "data/Zhao_trees/output/dBSum_deltaL1_Personly_Euclidean.txt";
	//getDistanceMatrixFixIndex(ZhaoEuclideanPath,ZhaoEuclideanOutput_dBSum);

	string outputFileDiameter = "data/Zhao_trees/output/zhao_trees_DiameterMat.txt";
	getDiameterDistMat(ZhaoEuclideanPath, outputFileDiameter);

	string EDoutput = "data/Zhao_trees/output/zhao_trees_dBSum_deltaLinfty_combMax.txt";
	combineDistMatTakeMax(outputFileDiameter,ZhaoEuclideanOutput_dBSum_Linfty, EDoutput);
	EDoutput = "data/Zhao_trees/output/zhao_trees_dBSum_deltaL1_combMax.txt";
	combineDistMatTakeMax(outputFileDiameter,ZhaoEuclideanOutput_dBSum_l1, EDoutput);
	EDoutput = "data/Zhao_trees/output/zhao_trees_dBSum_deltaLinfty_combSum.txt";
	combineDistMatAddUp(outputFileDiameter,ZhaoEuclideanOutput_dBSum_Linfty,EDoutput);
	EDoutput = "data/Zhao_trees/output/zhao_trees_dBSum_deltaL1_combSum.txt";
	combineDistMatAddUp(outputFileDiameter,ZhaoEuclideanOutput_dBSum_l1,EDoutput);

	string ZhaoEuclideanNNCoutput = "data/Zhao_trees/output/dBSum_deltaL1_Personly_Euclidean_euclideanNNC_NN.txt";
	//getNearestKNeighbor(ZhaoEuclideanOutput,ZhaoEuclideanNNCoutput, 5);

	ZhaoEuclideanNNCoutput = "data/Zhao_trees/output/dBSum_deltaLinfty_combMax_Euclidean_euclideanNNC_NN.txt";
	string EDoutput_KNN = "data/Zhao_trees/output/zhao_trees_dBSum_deltaLinfty_combMax.txt";
	getNearestKNeighbor(EDoutput_KNN,ZhaoEuclideanNNCoutput, 5);
	ZhaoEuclideanNNCoutput = "data/Zhao_trees/output/dBSum_deltaL1_combMax_Euclidean_euclideanNNC_NN.txt";
	EDoutput_KNN = "data/Zhao_trees/output/zhao_trees_dBSum_deltaL1_combMax.txt";
	getNearestKNeighbor(EDoutput_KNN,ZhaoEuclideanNNCoutput, 5);
	ZhaoEuclideanNNCoutput = "data/Zhao_trees/output/dBSum_deltaLinfty_combSum_Euclidean_euclideanNNC_NN.txt";
	EDoutput_KNN = "data/Zhao_trees/output/zhao_trees_dBSum_deltaLinfty_combSum.txt";
	getNearestKNeighbor(EDoutput_KNN,ZhaoEuclideanNNCoutput, 5);
	ZhaoEuclideanNNCoutput = "data/Zhao_trees/output/dBSum_deltaL1_combSum_Euclidean_euclideanNNC_NN.txt";
	EDoutput_KNN = "data/Zhao_trees/output/zhao_trees_dBSum_deltaL1_combSum.txt";
	getNearestKNeighbor(EDoutput_KNN,ZhaoEuclideanNNCoutput, 5);
}
